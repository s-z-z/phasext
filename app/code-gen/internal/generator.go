package internal

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	GenerateAnnotation = "// +code-gen:validate=true"

	templateStr = `
func (o *{{.StructName}}) ValidateStruct(v *validator.Validate) error {
	return v.Struct(o)
}
`
	templateHeaderStr = `package {{.PackageName}}

import (
	"github.com/go-playground/validator/v10"
)

// Code generated by generator; DO NOT EDIT.
`
)

type StructInfo struct {
	StructName string
}

type PackageInfo struct {
	PackageName string
}

func DirLoopGenerate(baseDir string) {
	dirs, _ := os.ReadDir(baseDir)
	for _, f := range dirs {
		if f.IsDir() && f.Name()[0] == 'v' {
			dirGenerate(baseDir, f)
		}
	}
}

func dirGenerate(baseDir string, d os.DirEntry) {
	files, _ := os.ReadDir(filepath.Join(baseDir, d.Name()))
	buf := bytes.Buffer{}

	for _, f := range files {
		if f.IsDir() || !strings.HasSuffix(f.Name(), ".go") || strings.HasPrefix(f.Name(), "zz_generated") {
			continue
		}
		fileI := filepath.Join(baseDir, d.Name(), f.Name())
		code, err := getFormattedCode(fileI)
		if err != nil {
			log.Fatalln(err)
		}
		if code != nil {
			buf.Write(code)
		}
	}
	if buf.Bytes() == nil {
		return
	}

	outF, err := getDirGenerateFile(baseDir, d)
	if err != nil {
		log.Fatalln(err)
	}

	writeHeader(d.Name(), outF)
	outF.Write(buf.Bytes())

	defer outF.Close()

}

func getDirGenerateFile(baseDir string, d os.DirEntry) (*os.File, error) {
	fPath := filepath.Join(baseDir, d.Name(), "zz_generated.validate.go")
	log.Println(fPath)

	outF, err := os.OpenFile(fPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return nil, err
	}
	return outF, nil
}

func writeHeader(pkg string, outF *os.File) {
	buf := bytes.Buffer{}
	tmpl, _ := template.New("header").Parse(templateHeaderStr)
	_ = tmpl.Execute(&buf, PackageInfo{
		PackageName: pkg,
	})
	outF.Write(buf.Bytes())
}

func getFormattedCode(filePath string) ([]byte, error) {
	// 解析文件
	fset := token.NewFileSet()
	sourceFile, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)

	if err != nil {
		return nil, err
	}
	// 查找带有注释的结构体
	structs := findAnnotatedStructs(sourceFile)

	// 创建模板
	tmpl, err := template.New("validateMethods").Parse(templateStr)
	if err != nil {
		return nil, err
	}

	// 生成代码
	var buf bytes.Buffer
	for _, structInfo := range structs {
		if err := tmpl.Execute(&buf, structInfo); err != nil {
			return nil, err
		}
	}

	// 格式化生成的代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return formattedCode, nil
}

func findAnnotatedStructs(file *ast.File) []StructInfo {
	var structs []StructInfo

	for _, decl := range file.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
			for _, spec := range genDecl.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					// 检查是否有注释
					hasAnnotation := false
					for _, comment := range file.Comments {
						for _, c := range comment.List {
							if c.Text == GenerateAnnotation {
								hasAnnotation = true
								break
							}
						}
						if hasAnnotation {
							break
						}
					}

					if hasAnnotation {
						structs = append(structs, StructInfo{StructName: typeSpec.Name.Name})
					}
				}
			}
		}
	}

	return structs
}
